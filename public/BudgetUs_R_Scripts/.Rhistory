country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)
gregexpr(">*</a>",workDat[date])
gregexpr(">[\w\d\s]*</a>,workDat[date])
gregexpr(">[\\w\\d\\s]*</a>",workDat[date])
workDat[date]
gregexpr(">[\\w\\d\\s]*</a>",workDat[country])
workDat[country]
gregexpr(">Netherlands</a>",workDat[country])
gregexpr(">[\\w\\d\\s]*</a>",workDat[country])
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]]
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]
?substr
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][2]
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][3]
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[2]]
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[1]
gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[1][1]
attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T))
attr(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T))
attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])
attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1]
attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][1]
attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]
countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]-1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-5#
	substr(workDat[country],countryStart,countryStop)
countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-5#
	substr(workDat[country],countryStart,countryStop)
countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	substr(workDat[country],countryStart,countryStop)
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
#
	output[i,] = c(countryName,dateName,typeName)#
}
output
setwd('users/raulfoo/Desktop/')#
dat = readLines('http://www.electionguide.org/calendar.php')#
#
starts = grep('<tr class="color',dat)#
#
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
#
	output[i,] = c(countryName,dateName,typeName)#
}
output
setwd('users/raulfoo/Desktop/')#
dat = readLines('http://www.electionguide.org/calendar.php')#
#
starts = grep('<tr class="color',dat)#
#
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s]*</q>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</q>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
#
	output[i,] = c(countryName,dateName,typeName)#
}
output
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s[:punct:]]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
#
	output[i,] = c(countryName,dateName,typeName)#
}
output
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s,]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
#
	output[i,] = c(countryName,dateName,typeName)#
}
output
i = 1
if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]
workDat
country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)
workDat[date]
dateStart = gregexpr(">[\\w\\d\\s,]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)
dateName
dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)
dateName
dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)
dateName
dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = countryStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)
dateName
dateStart
dateStop
attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
#
	output[i,] = c(countryName,dateName,typeName)#
}
output
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
output
i = 5
if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	date = grep('<td class="last">',workDat)
type
utput = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(type==NA) type = grep('<td>',workDat)[3]#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(type==NA) type = grep('<td>',workDat)[3]#
	date = grep('<td class="last">',workDat)
(type==NA
)
if(type=='NA') type = grep('<td>',workDat)[3]
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	typeCheck = 0#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(type=='NA') {#
		type = grep('<td>',workDat)[3]#
typeCheck = 1#
	}	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	if(typeCheck == 0){#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	}#
	if(typeCheck ==1){#
		typeStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
		}#
	}#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	typeCheck = 0#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(type=='NA') {#
		type = grep('<td>',workDat)[3]#
typeCheck = 1#
	}	#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	if(typeCheck == 0){#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	}#
	if(typeCheck ==1){#
		typeStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
		}#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
i
type=='NA'
type
is.na(type)
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	typeCheck = 0#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(is.na(type)==T) {#
		type = grep('<td>',workDat)[3]#
typeCheck = 1#
	}	#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	if(typeCheck == 0){#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	}#
	if(typeCheck ==1){#
		typeStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
		}#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
output
i = 5
typeCheck = 0#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(is.na(type)==T) {#
		type = grep('<td>',workDat)[3]#
typeCheck = 1#
	}	#
	date = grep('<td class="last">',workDat)
type
grep('<td>',workDat)
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	typeCheck = 0#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(is.na(type)==T) {#
		type = grep('<td>',workDat)[2]#
typeCheck = 1#
	}	#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	if(typeCheck == 0){#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	}#
	if(typeCheck ==1){#
		typeStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
		}#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
output
output = array(dim=c(length(starts),3))#
for(i in 1:length(starts)){#
	typeCheck = 0#
	if(i == length(starts)) workDat = dat[starts[i]:(starts[i]+7)]#
    if(i<length(starts)) workDat = dat[starts[i]:starts[(i+1)]-1]#
#
	country = grep('<td><a href',workDat)[1]#
	type = grep('<td><a href',workDat)[2]#
	if(is.na(type)==T) {#
		type = grep('<td>',workDat)[2]#
typeCheck = 1#
	}	#
	date = grep('<td class="last">',workDat)#
	countryStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]][1]+1#
	countryStop = countryStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[country],perl=T)[[1]])[1][[1]]-6#
	countryName = substr(workDat[country],countryStart,countryStop)	#
	if(typeCheck == 0){#
	typeStart = gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</a>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
	}#
	if(typeCheck ==1){#
		typeStart = gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]][1]+1#
	typeStop = typeStart + attributes(gregexpr(">[\\w\\d\\s]*</td>",workDat[type],perl=T)[[1]])[1][[1]]-6#
	typeName = substr(workDat[type],typeStart,typeStop)	#
		typeName = gsub("[<>]","",typeName)#
		}#
	dateStart = gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]][1]+1#
	dateStop = dateStart + attributes(gregexpr(">[\\w\\d\\s\\D\\W\\S]*</td>",workDat[date],perl=T)[[1]])[1][[1]]-6#
	dateName = substr(workDat[date],dateStart,dateStop)	#
	dateName = gsub("[<>]","",dateName)#
	output[i,] = c(countryName,dateName,typeName)#
}
output
write.csv(output,'FutureElections.csv',row.names=F)
dat = read.table("/Users/raulfoo/Desktop/tempUpload.txt",stringsAsFactors=F,sep=",")
dat
output = c()#
output = rbind(output,c("F-35",12345,'t'))#
output = rbind(output,c("Defense",13212345,'t'))#
output = rbind(output,c("EPA",14,'t'))#
#
write.table(output,"temp.txt",row.names=F,col.names=F,sep=",")
output = c()#
output = rbind(output,c("F-35",12345,'t'))#
output = rbind(output,c("Defense",13212345,'t'))#
output = rbind(output,c("EPA",14,'t'))#
#
write.table(output,"/Users/raulfoo/Desktop/temp.txt",row.names=F,col.names=F,sep=",")
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
#
topLevels = grep("All -- Total|All -- List",firstPart[,2])#
#
topLevelsFirst = topLevels[which(firstPart[topLevels,9]=="subfunction")]#
#
topLevels = grep("All -- Total|All -- List",secondPart[,2])#
#
topLevelsSecond = topLevels[which(secondPart[topLevels,9]=="agency")]+nrow(firstPart)#
topLevels = c(topLevelsFirst,topLevelsSecond)#
#
#pick subfunction and unnested subfunctions#
#topLevels = which(output[,4]!="f") #
dat = read.table("BudgetUs_Comprehensive.txt",sep=",",stringsAsFactors=F)#
dat = dat[which(dat[,7]==2012),]#
budgetSum = c()#
#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(workDat[,2])) <= abs(as.numeric(workDat[i,2])*1.5) & abs(as.numeric(workDat[,2])) >= abs(as.numeric(workDat[i,2])*.5) & workDat[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(workDat[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
#temp=c(1,20,3,67,73,64,18)#
#x = output[temp,]#
#
#y = paste(x[,10],collapse=",")#
#z = strsplit(y,",")[[1]]#
#search = paste("^",z,"$",sep="",collapse="|")#
#
#a = grep(search,dat[,5])#
#
#make a comparison_neighbors column#
neighborsList = c()#
badNeighbors =c()#
for(i in 1:nrow(output)){#
	if(output[i,7] != 0){#
	parent = which(output[,1] == output[i,7])#
	neighbors = output[parent,6]#
	neighbors = strsplit(neighbors,",")[[1]]#
	neighbors = neighbors[3:length(neighbors)]#
	if(length(neighbors)<2) badNeighbors = c(badNeighbors,i)#
	neighbors = neighbors[sample(1:length(neighbors),min(6,length(neighbors)))]#
	neighbors = unique(c(output[i,1],neighbors))#
	neighbors = paste(neighbors,collapse=",")#
	}else{#
		neighbors = 0#
	}#
	neighborsList = c(neighborsList,neighbors)#
}#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
#output = cbind(output,neighborsList)#
#
#lets do something to add neighbors for ones that are nested without many natural neighbors#
#
budgetSum = c()#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
budgetSum = c()#
aggregates = grep("All -- List|All -- Total",output[,3])#
topLevels = output[-aggregates,1]#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
Eligibles = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*1.5) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)
output[2837,]
output[2838,]
output[187,]
output[51,]
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#
dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
workDat=dat#
#workDat[,2] = paste(temp[,2],temp[,1],sep=",")#
#workDat[,3] = paste(temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,4] = paste(temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#
#---IMPORTANT---#
#here is where we can change specificty#
#with all levels, payment at program level has to be traced back to the subfunction, which can lead to some weird numbers sometimes, if only start this on workDat[,3], leaving out the subfunction nesting, then will have more generalized (and maybe better) numbers. (but will need to retain the first subfunction rows so the search will be connected) Also, if change the --> connector, need to change code at bottom of search_programs library#
workDat[,2] = paste(dat[,1],dat[,2],sep="-->")#
workDat[,3] = paste(dat[,1],dat[,2],dat[,3],sep="-->")#
workDat[,4] = paste(dat[,1],dat[,2],dat[,3],dat[,4],sep="-->")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
uniqueSearch = c()#
thresholds = c()#
for(i in c(1:4)){#
	uniqueSearch = c(uniqueSearch,unique(workDat[,i]))#
	thresholds = rbind(thresholds,c(i,length(uniqueSearch)))#
	#take the measurement before add the ids#
	if(i == 3) searchLength = length(uniqueSearch)#
} #
#
uniqueSearch = gsub("\\(","--",uniqueSearch)#
uniqueSearch = gsub("\\)","--",uniqueSearch)#
thresholds = cbind(thresholds,c("subfunction","agency","bureau","program"))#
branchAddresses = c()#
for(j in 1:searchLength){#
	search_r = which(as.numeric(thresholds[,2])>=j)[1]#
	searchRange = c(((as.numeric(thresholds[search_r,2]))+1),as.numeric(thresholds[search_r+1,2]))#
	branchMap = grep(paste(uniqueSearch[j],"-->",sep=""),uniqueSearch)#
	branchMapSelect = which(branchMap>=searchRange[1] & branchMap<=searchRange[2])#
	branchMap = branchMap[branchMapSelect]#
	branchMap = paste(branchMap,collapse=",")#
	branchAddresses = rbind(branchAddresses,branchMap)#
#
	if(j %% 250 == 0) print(j)#
}#
#
#uniqueIds Column#
uniqueIds = c(1:length(uniqueSearch))#
#
#Browse names (last entry in the unqiueSearch)#
browseNames = c()#
base_level = c()#
index = 0#
for(i in uniqueSearch){#
	splits = strsplit(i,"-->")[[1]]#
	splitLength = length(splits)#
	thisBaseLevel = thresholds[splitLength,3]#
	browseWord = splits[splitLength]#
	browseNames = c(browseNames,browseWord)#
	base_level = c(base_level,thisBaseLevel)#
	if(index %% 250 == 0) print(index)#
	index = index+1#
}#
#
#searchable (only the first 80 entries)#
trueSearch = rep("nested",times=thresholds[1,2])#
falseSearch = rep("f",times=(length(uniqueSearch)-length(trueSearch)))#
#
searchables = c(trueSearch,falseSearch)#
#text search (same as searchables for now)#
textSearch = rep("f",times=length(searchables))#
#setup BranchId column#
#add zero values to branchMap for the account levels#
zeroes = rep(0, times=(length(uniqueSearch)-searchLength))#
branchAddressesAddColumn = c(branchAddresses,zeroes)
j = uniqueSearch[51]
j
searchIndex = which(workDat[,4]==j)
searchIndex
grep("INTEREST ON TREASURY DEBT SECURITIES",workDat[,4])
workDat[c(898,899,900,901),]
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#remove records where 2012 or 2013 = 0#
dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#
removes = which(dat[,64]==0 | dat[,65]==0) #
dat = dat[-removes,]#
dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
dat = dat[is.na(dat[,3])==F,]#
#
newID = c(1:dim(dat)[1])#
dat[,3] = newID#
temp = cbind(dat[,5],dat[,1],dat[,2],dat[,4],dat[,3],dat[,6])#
temp = toupper(temp)#
temp = cbind(temp,dat[,7:ncol(dat)]*1000)#
#
temp[,4] = gsub("\\(","--",temp[,4])#
temp[,4] = gsub("\\)","--",temp[,4])#
dat = temp#
#
#remove duplicates#
for(j in 1:nrow(dat)){#
	search = dat[j,]#
	indices = which(dat[,1]==search[,1]&dat[,2]==search[,2]&dat[,3]==search[,3]&dat[,4]==search[,4])#
	if(length(indices)>1){#
		removeRows = indices[2:length(indices)]#
		sums = as.numeric(apply(dat[indices,7:ncol(dat)],2,sum))#
		dat[j,7:ncol(dat)] = sums#
		#newRow = c(dat[j,1:6],sums)#
		#dat[j,] = newRow#
		dat = dat[-removeRows,]		#
	}#
	if(j%%250 == 0) print(j)#
}#
#
names(dat)[1:6] = c("SubFunction","Agency","Bureau","Account","Accunt Number","Spending Type")#
#
write.table(dat,"BudgetUS_Cleaned.txt",sep=",",row.names=F,col.names=F)#
#dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)
dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
workDat=dat
workDat[898:901,]
j
j = uniqueSearches[51]
j = uniqueSearch[51]
j
which(workDat[,4]==j)
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#
dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
workDat=dat#
#workDat[,2] = paste(temp[,2],temp[,1],sep=",")#
#workDat[,3] = paste(temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,4] = paste(temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#
#---IMPORTANT---#
#here is where we can change specificty#
#with all levels, payment at program level has to be traced back to the subfunction, which can lead to some weird numbers sometimes, if only start this on workDat[,3], leaving out the subfunction nesting, then will have more generalized (and maybe better) numbers. (but will need to retain the first subfunction rows so the search will be connected) Also, if change the --> connector, need to change code at bottom of search_programs library#
workDat[,2] = paste(dat[,1],dat[,2],sep="-->")#
workDat[,3] = paste(dat[,1],dat[,2],dat[,3],sep="-->")#
workDat[,4] = paste(dat[,1],dat[,2],dat[,3],dat[,4],sep="-->")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
uniqueSearch = c()#
thresholds = c()#
for(i in c(1:4)){#
	uniqueSearch = c(uniqueSearch,unique(workDat[,i]))#
	thresholds = rbind(thresholds,c(i,length(uniqueSearch)))#
	#take the measurement before add the ids#
	if(i == 3) searchLength = length(uniqueSearch)#
} #
#
uniqueSearch = gsub("\\(","--",uniqueSearch)#
uniqueSearch = gsub("\\)","--",uniqueSearch)#
thresholds = cbind(thresholds,c("subfunction","agency","bureau","program"))#
branchAddresses = c()#
for(j in 1:searchLength){#
	search_r = which(as.numeric(thresholds[,2])>=j)[1]#
	searchRange = c(((as.numeric(thresholds[search_r,2]))+1),as.numeric(thresholds[search_r+1,2]))#
	branchMap = grep(paste(uniqueSearch[j],"-->",sep=""),uniqueSearch)#
	branchMapSelect = which(branchMap>=searchRange[1] & branchMap<=searchRange[2])#
	branchMap = branchMap[branchMapSelect]#
	branchMap = paste(branchMap,collapse=",")#
	branchAddresses = rbind(branchAddresses,branchMap)#
#
	if(j %% 250 == 0) print(j)#
}#
#
#uniqueIds Column#
uniqueIds = c(1:length(uniqueSearch))#
#
#Browse names (last entry in the unqiueSearch)#
browseNames = c()#
base_level = c()#
index = 0#
for(i in uniqueSearch){#
	splits = strsplit(i,"-->")[[1]]#
	splitLength = length(splits)#
	thisBaseLevel = thresholds[splitLength,3]#
	browseWord = splits[splitLength]#
	browseNames = c(browseNames,browseWord)#
	base_level = c(base_level,thisBaseLevel)#
	if(index %% 250 == 0) print(index)#
	index = index+1#
}#
#
#searchable (only the first 80 entries)#
trueSearch = rep("nested",times=thresholds[1,2])#
falseSearch = rep("f",times=(length(uniqueSearch)-length(trueSearch)))#
#
searchables = c(trueSearch,falseSearch)#
#text search (same as searchables for now)#
textSearch = rep("f",times=length(searchables))#
#setup BranchId column#
#add zero values to branchMap for the account levels#
zeroes = rep(0, times=(length(uniqueSearch)-searchLength))#
branchAddressesAddColumn = c(branchAddresses,zeroes)#
#
#add account Ids for the lowest level, 0 for the others#
accountIds = c()#
for(j in uniqueSearch){#
	searchIndex = which(workDat[,4]==j)#
#
	if(length(searchIndex)>0){#
		value = workDat[searchIndex,5]#
	}else{#
		value = 0#
	}#
	if(length(value)>1) {#
		print("greater than 1..")#
		print(j)#
		print(value)#
	}	#
	accountIds = c(accountIds,value)#
}#
#
#base_level = rep("NA",times=length(uniqueSearch))#
#columns are (7)#
#1 unique search ID#
#2 search name, including all super levels#
#3 search name used for browsing (lowest level)#
#4 boolean, is this used for the first selection option#
#5 boolean, can this be searched with text (all the lowest levels, and the aggregates)#
#6 branches, unique search ids that are connected one level below this entry#
#7 trunks (parents) the 1 unique search value that can be associated with every branch#
#8 govt account ID numbers that comprise this entry (only for the aggregates and lowest levels)#
#9 sort value(for sorting in the browse window, aggregates get 1 and 2, everythin else is 0)#
#10 base level agency#
#
trunkIds = rep(0,rep=length(uniqueSearch))#
sortValues = rep(0,times=length(uniqueSearch))#
output = cbind(uniqueIds,uniqueSearch,browseNames,searchables,textSearch,branchAddressesAddColumn,trunkIds,accountIds,sortValues,base_level)#
for(trunkIndex in c(1:nrow(output))){#
	branches = as.numeric(strsplit(output[trunkIndex,6],",")[[1]])#
	output[branches,7] = trunkIndex#
}#
#
for(addStems in c(1:nrow(output))){#
	if(as.numeric(output[addStems,7])==0){#
		output[addStems,7] = output[addStems,1]#
	}#
}#
outputRowIndex = 1#
#
originalLength = nrow(output)#
for(k in 1:originalLength){#
	search = output[k,6]#
	rows = as.numeric(strsplit(search,",")[[1]])#
	branchList = c(rows)#
	maxIndex = 10#
	indexCount = 1#
	if(rows!=0 & length(rows)>0){#
		while(T){#
			testBranch = c()#
			rowSearch = output[rows,6]#
			for(eachRow in rowSearch){#
				rowStep = as.numeric(strsplit(eachRow[[1]],",")[[1]])#
				branchList = c(branchList,rowStep)#
				testBranch = c(testBranch,rowStep)#
				}#
			if(max(testBranch)==0) break#
			if(indexCount >= maxIndex) break#
			 #failsafe#
			indexCount = indexCount+1#
			rows = testBranch#
		}#
		account_ids = rows[which(rows>0)]#
		account_ids = output[account_ids,8]#
		temp = which(account_ids=="0")#
		if(length(temp)>0){#
			account_ids = account_ids[-temp]#
		}#
	}else{#
		account_ids = 0#
		}#
	#create 'All' entry#
	if(outputRowIndex <= searchLength){#
		trunkIndex = as.numeric(output[outputRowIndex,7])#
		#trunkIndex = outputRowIndex#
		unique_id = nrow(output)+1#
		textSearch = "t"#
		account_ids = unique(account_ids)#
		#if(outputRowIndex <= thresholds[,2]) textSearch = "t"#
		browseName = paste(output[outputRowIndex,3]," (All -- Total)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- Total)",sep="")#
#
		baseLevelCategory = output[outputRowIndex,10]#
		branch_ids = unique_id#
        #for the subfunction level only aggregates, need to make the trunkIndex = 0#
        if(output[outputRowIndex,10]=="subfunction") trunkIndex = 0  #
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,	branch_ids,trunkIndex,paste("All",paste(account_ids,collapse=","),sep=","),1,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#trunkIndex = as.numeric(output[outputRowIndex,7])#
		trunkIndex = outputRowIndex#
#
		unique_id = nrow(output)+1#
		browseName = paste(output[outputRowIndex,3]," (All -- List)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- List)",sep="")	#
		branch_ids = output[outputRowIndex,6]#
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,	branch_ids,trunkIndex,paste(account_ids,collapse=","),2,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#add these two to the branch Ids for the origianl search#
		output[outputRowIndex,6] = paste((nrow(output)-1),nrow(output),output[outputRowIndex,6],sep=",")#
		#if need to, add the account ids to this row as well, but shouldn't need too, as only will be accesses#
		output[outputRowIndex,8] = paste(account_ids,collapse=",")#
		#output[outputRowIndex,10] = baseLevelCategory#
	}#
	outputRowIndex = outputRowIndex +1#
	if((outputRowIndex %% 100) == 0) print(outputRowIndex)#
}	#
#
write.table(output,"uniqueSearches.txt",sep=",",col.names=F,row.names=F)#
allNests = c()#
workOutput = output[(originalLength+1):nrow(output),]#
workOutput[,2] = gsub("\\(","--",workOutput[,2])#
workOutput[,2] = gsub("\\)","--",workOutput[,2])#
for(nest in c(2:4)){#
	nestingValues = c()#
	#for(i in c(1:originalLength)){#
		for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "subfunction"){#
			rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
allNestsTemp = array(dim=c(originalLength,3),0) #
allNests = rbind(allNestsTemp,allNests)#
#output = cbind(output[,-8],output[,8])#
#
output = cbind(output,allNests)#
#
allNests = c()#
workOutput = output[1:originalLength,]#
#
for(nest in c(2:4)){#
	nestingValues = c()#
	#for(i in c(1:originalLength)){#
		for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "subfunction"){#
				rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
#allNestsTemp = array(dim=c((nrow(output)-nrow(allNests)),3),0)  #this is to cover all the aggregates#
#move account Ids to end#
#allNests = rbind(allNests,allNestsTemp)#
#output = cbind(output[,-8],output[,8])#
#output = cbind(output,allNests)#
#output = cbind(output[,-8],output[,8])#
#output = cbind(output,allNests)#
#
output[c(1:nrow(allNests)),c((ncol(output)-2):ncol(output))] = allNests#
#
output = cbind(output[,-c(8,(ncol(output)-2),(ncol(output)-1),ncol(output))],output[,8],output[,c((ncol(output)-2):ncol(output))])#
write.table(output,"uniqueSearchesNested.txt",sep=",",col.names=F,row.names=F)#
#
#nesting levels, 1 = default, fully nested, 2 = nested to two programs above, 3 = nested to program immediately above, 4 = no nesting, so, the higher the nest the number, the more account ids there should be associated with it#
#so, allNests should be a originalLengthx3 array, where the first column = account ids to use when they search for a nesting level of 2, second column is nesting level of 3
setwd("/Users/raulfoo/Desktop")#
#
#dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
#dat = dat[is.na(dat[,3])==F,]#
#
#newID = c(1:dim(dat)[1])#
#dat[,3] = newID#
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#remove records where 2012 or 2013 = 0#
dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#
removes = which(dat[,64]==0 | dat[,65]==0) #
dat = dat[-removes,]#
dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
dat = dat[is.na(dat[,3])==F,]#
#
newID = c(1:dim(dat)[1])#
dat[,3] = newID#
temp = cbind(dat[,5],dat[,1],dat[,2],dat[,4],dat[,3],dat[,6])#
temp = toupper(temp)#
temp = cbind(temp,dat[,7:ncol(dat)]*1000)#
#
temp[,4] = gsub("\\(","--",temp[,4])#
temp[,4] = gsub("\\)","--",temp[,4])#
dat = temp#
#
#remove duplicates#
for(j in 1:nrow(dat)){#
	search = dat[j,]#
	indices = which(dat[,1]==search[,1]&dat[,2]==search[,2]&dat[,3]==search[,3]&dat[,4]==search[,4])#
	if(length(indices)>1){#
		removeRows = indices[2:length(indices)]#
		sums = as.numeric(apply(dat[indices,7:ncol(dat)],2,sum))#
		dat[j,7:ncol(dat)] = sums#
		#newRow = c(dat[j,1:6],sums)#
		#dat[j,] = newRow#
		dat = dat[-removeRows,]		#
	}#
	if(j%%250 == 0) print(j)#
}#
#
names(dat)[1:6] = c("SubFunction","Agency","Bureau","Account","Accunt Number","Spending Type")#
#
write.table(dat,"BudgetUS_Cleaned.txt",sep=",",row.names=F,col.names=F)#
#dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
newDat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#removes = which(newDat[,64]==0 | neDat[,65]==0) #
#newDat = newDat[-removes,]#
newDat= newDat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
newDat = newDat[is.na(newDat[,3])==F,]#
#
newID = c(1:dim(newDat)[1])#
newDat[,3] = newID#
temp = cbind(newDat[,5],newDat[,1],newDat[,2],newDat[,4],newDat[,3],newDat[,6])#
temp = toupper(temp)#
temp[,4] = gsub("\\(","--",temp[,4])#
temp[,4] = gsub("\\)","--",temp[,4])#
#
temp = cbind(temp,newDat[,7:ncol(newDat)]*1000)#
#
newDat = temp#
#
#remove duplicates#
for(j in 1:nrow(newDat)){#
	search = newDat[j,]#
	indices = which(newDat[,1]==search[,1]&newDat[,2]==search[,2]&newDat[,3]==search[,3]&newDat[,4]==search[,4])#
	if(length(indices)>1){#
		removeRows = indices[2:length(indices)]#
		sums = as.numeric(apply(newDat[indices,7:ncol(newDat)],2,sum))#
		newDat[j,7:ncol(newDat)] = sums#
		#newRow = c(dat[j,1:6],sums)#
		#dat[j,] = newRow#
		newDat = newDat[-removeRows,]		#
	}#
	if(j%%250 == 0) print(j)#
}#
#
names(newDat)[1:6] = c("SubFunction","Agency","Bureau","Account","Accunt Number","Spending Type")#
yearUse = c(1980:2015)#
#
averages = apply(dat[,c(7:ncol(dat))],1,mean)#
removePositives = which(averages < 0)#
#dat = dat[-removePositives,]#
#
#temp = cbind(dat[,3],dat[,-3])#
#dat = temp#
output = c()#
for(year in yearUse){#
	colIndex = which(names(dat)==paste("X",year,sep=""))#
	#total = sum(as.numeric(dat[,colIndex]))#
	total = sum(as.numeric(newDat[,colIndex]))#
	restrictedTotal = sum(as.numeric(dat[,colIndex]))#
	medicare = which(dat[,1]=="MEDICARE")#
	ss = which(dat[,1]=="SOCIAL SECURITY")#
	plain = c(1:nrow(dat))[-c(ss,medicare)]#
	restrictedTotal[medicare] = sum(as.numeric(dat[medicare,colIndex]))#
	restrictedTotal[ss] = sum(as.numeric(dat[ss,colIndex]))#
	restrictedTotal[plain] = sum(as.numeric(dat[plain,colIndex]))#
	print(paste(year,"  :  ",total))#
	temp = cbind(dat[,c(1:6)],year,dat[,colIndex]/total,dat[,colIndex]/restrictedTotal,dat[,colIndex],"f")#
	names(temp) = NA#
	output = rbind(output,temp)#
	names(output) = NA#
}#
output[,ncol(output)] = as.character(output[,ncol(output)])#
for(i in 1:nrow(output)){#
	if(output[i,1]=="SOCIAL SECURITY"){ #
		output[i,ncol(output)] = "SS"	#
	}else if(output[i,1]=="MEDICARE"){#
		output[i,ncol(output)] = "Medicare"	#
	}#
}#
write.table(output,"BudgetUs_Comprehensive.txt",sep=",",col.names=F,row.names=F)
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#
dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
workDat=dat#
#workDat[,2] = paste(temp[,2],temp[,1],sep=",")#
#workDat[,3] = paste(temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,4] = paste(temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#
#---IMPORTANT---#
#here is where we can change specificty#
#with all levels, payment at program level has to be traced back to the subfunction, which can lead to some weird numbers sometimes, if only start this on workDat[,3], leaving out the subfunction nesting, then will have more generalized (and maybe better) numbers. (but will need to retain the first subfunction rows so the search will be connected) Also, if change the --> connector, need to change code at bottom of search_programs library#
workDat[,2] = paste(dat[,1],dat[,2],sep="-->")#
workDat[,3] = paste(dat[,1],dat[,2],dat[,3],sep="-->")#
workDat[,4] = paste(dat[,1],dat[,2],dat[,3],dat[,4],sep="-->")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
uniqueSearch = c()#
thresholds = c()#
for(i in c(1:4)){#
	uniqueSearch = c(uniqueSearch,unique(workDat[,i]))#
	thresholds = rbind(thresholds,c(i,length(uniqueSearch)))#
	#take the measurement before add the ids#
	if(i == 3) searchLength = length(uniqueSearch)#
} #
#
uniqueSearch = gsub("\\(","--",uniqueSearch)#
uniqueSearch = gsub("\\)","--",uniqueSearch)#
thresholds = cbind(thresholds,c("subfunction","agency","bureau","program"))#
branchAddresses = c()#
for(j in 1:searchLength){#
	search_r = which(as.numeric(thresholds[,2])>=j)[1]#
	searchRange = c(((as.numeric(thresholds[search_r,2]))+1),as.numeric(thresholds[search_r+1,2]))#
	branchMap = grep(paste(uniqueSearch[j],"-->",sep=""),uniqueSearch)#
	branchMapSelect = which(branchMap>=searchRange[1] & branchMap<=searchRange[2])#
	branchMap = branchMap[branchMapSelect]#
	branchMap = paste(branchMap,collapse=",")#
	branchAddresses = rbind(branchAddresses,branchMap)#
#
	if(j %% 250 == 0) print(j)#
}#
#
#uniqueIds Column#
uniqueIds = c(1:length(uniqueSearch))#
#
#Browse names (last entry in the unqiueSearch)#
browseNames = c()#
base_level = c()#
index = 0#
for(i in uniqueSearch){#
	splits = strsplit(i,"-->")[[1]]#
	splitLength = length(splits)#
	thisBaseLevel = thresholds[splitLength,3]#
	browseWord = splits[splitLength]#
	browseNames = c(browseNames,browseWord)#
	base_level = c(base_level,thisBaseLevel)#
	if(index %% 250 == 0) print(index)#
	index = index+1#
}#
#
#searchable (only the first 80 entries)#
trueSearch = rep("nested",times=thresholds[1,2])#
falseSearch = rep("f",times=(length(uniqueSearch)-length(trueSearch)))#
#
searchables = c(trueSearch,falseSearch)#
#text search (same as searchables for now)#
textSearch = rep("f",times=length(searchables))#
#setup BranchId column#
#add zero values to branchMap for the account levels#
zeroes = rep(0, times=(length(uniqueSearch)-searchLength))#
branchAddressesAddColumn = c(branchAddresses,zeroes)#
#
#add account Ids for the lowest level, 0 for the others#
accountIds = c()#
for(j in uniqueSearch){#
	searchIndex = which(workDat[,4]==j)#
#
	if(length(searchIndex)>0){#
		value = workDat[searchIndex,5]#
	}else{#
		value = 0#
	}#
	if(length(value)>1) {#
		print("greater than 1..")#
		print(j)#
		print(value)#
	}	#
	accountIds = c(accountIds,value)#
}#
#
#base_level = rep("NA",times=length(uniqueSearch))#
#columns are (7)#
#1 unique search ID#
#2 search name, including all super levels#
#3 search name used for browsing (lowest level)#
#4 boolean, is this used for the first selection option#
#5 boolean, can this be searched with text (all the lowest levels, and the aggregates)#
#6 branches, unique search ids that are connected one level below this entry#
#7 trunks (parents) the 1 unique search value that can be associated with every branch#
#8 govt account ID numbers that comprise this entry (only for the aggregates and lowest levels)#
#9 sort value(for sorting in the browse window, aggregates get 1 and 2, everythin else is 0)#
#10 base level agency#
#
trunkIds = rep(0,rep=length(uniqueSearch))#
sortValues = rep(0,times=length(uniqueSearch))#
output = cbind(uniqueIds,uniqueSearch,browseNames,searchables,textSearch,branchAddressesAddColumn,trunkIds,accountIds,sortValues,base_level)#
for(trunkIndex in c(1:nrow(output))){#
	branches = as.numeric(strsplit(output[trunkIndex,6],",")[[1]])#
	output[branches,7] = trunkIndex#
}#
#
for(addStems in c(1:nrow(output))){#
	if(as.numeric(output[addStems,7])==0){#
		output[addStems,7] = output[addStems,1]#
	}#
}#
outputRowIndex = 1#
#
originalLength = nrow(output)#
for(k in 1:originalLength){#
	search = output[k,6]#
	rows = as.numeric(strsplit(search,",")[[1]])#
	branchList = c(rows)#
	maxIndex = 10#
	indexCount = 1#
	if(rows!=0 & length(rows)>0){#
		while(T){#
			testBranch = c()#
			rowSearch = output[rows,6]#
			for(eachRow in rowSearch){#
				rowStep = as.numeric(strsplit(eachRow[[1]],",")[[1]])#
				branchList = c(branchList,rowStep)#
				testBranch = c(testBranch,rowStep)#
				}#
			if(max(testBranch)==0) break#
			if(indexCount >= maxIndex) break#
			 #failsafe#
			indexCount = indexCount+1#
			rows = testBranch#
		}#
		account_ids = rows[which(rows>0)]#
		account_ids = output[account_ids,8]#
		temp = which(account_ids=="0")#
		if(length(temp)>0){#
			account_ids = account_ids[-temp]#
		}#
	}else{#
		account_ids = 0#
		}#
	#create 'All' entry#
	if(outputRowIndex <= searchLength){#
		trunkIndex = as.numeric(output[outputRowIndex,7])#
		#trunkIndex = outputRowIndex#
		unique_id = nrow(output)+1#
		textSearch = "t"#
		account_ids = unique(account_ids)#
		#if(outputRowIndex <= thresholds[,2]) textSearch = "t"#
		browseName = paste(output[outputRowIndex,3]," (All -- Total)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- Total)",sep="")#
#
		baseLevelCategory = output[outputRowIndex,10]#
		branch_ids = unique_id#
        #for the subfunction level only aggregates, need to make the trunkIndex = 0#
        if(output[outputRowIndex,10]=="subfunction") trunkIndex = 0  #
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,	branch_ids,trunkIndex,paste("All",paste(account_ids,collapse=","),sep=","),1,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#trunkIndex = as.numeric(output[outputRowIndex,7])#
		trunkIndex = outputRowIndex#
#
		unique_id = nrow(output)+1#
		browseName = paste(output[outputRowIndex,3]," (All -- List)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- List)",sep="")	#
		branch_ids = output[outputRowIndex,6]#
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,	branch_ids,trunkIndex,paste(account_ids,collapse=","),2,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#add these two to the branch Ids for the origianl search#
		output[outputRowIndex,6] = paste((nrow(output)-1),nrow(output),output[outputRowIndex,6],sep=",")#
		#if need to, add the account ids to this row as well, but shouldn't need too, as only will be accesses#
		output[outputRowIndex,8] = paste(account_ids,collapse=",")#
		#output[outputRowIndex,10] = baseLevelCategory#
	}#
	outputRowIndex = outputRowIndex +1#
	if((outputRowIndex %% 100) == 0) print(outputRowIndex)#
}	#
#
write.table(output,"uniqueSearches.txt",sep=",",col.names=F,row.names=F)#
allNests = c()#
workOutput = output[(originalLength+1):nrow(output),]#
workOutput[,2] = gsub("\\(","--",workOutput[,2])#
workOutput[,2] = gsub("\\)","--",workOutput[,2])#
for(nest in c(2:4)){#
	nestingValues = c()#
	#for(i in c(1:originalLength)){#
		for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "subfunction"){#
			rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
allNestsTemp = array(dim=c(originalLength,3),0) #
allNests = rbind(allNestsTemp,allNests)#
#output = cbind(output[,-8],output[,8])#
#
output = cbind(output,allNests)#
#
allNests = c()#
workOutput = output[1:originalLength,]#
#
for(nest in c(2:4)){#
	nestingValues = c()#
	#for(i in c(1:originalLength)){#
		for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "subfunction"){#
				rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
#allNestsTemp = array(dim=c((nrow(output)-nrow(allNests)),3),0)  #this is to cover all the aggregates#
#move account Ids to end#
#allNests = rbind(allNests,allNestsTemp)#
#output = cbind(output[,-8],output[,8])#
#output = cbind(output,allNests)#
#output = cbind(output[,-8],output[,8])#
#output = cbind(output,allNests)#
#
output[c(1:nrow(allNests)),c((ncol(output)-2):ncol(output))] = allNests#
#
output = cbind(output[,-c(8,(ncol(output)-2),(ncol(output)-1),ncol(output))],output[,8],output[,c((ncol(output)-2):ncol(output))])#
write.table(output,"uniqueSearchesNested.txt",sep=",",col.names=F,row.names=F)#
#
#nesting levels, 1 = default, fully nested, 2 = nested to two programs above, 3 = nested to program immediately above, 4 = no nesting, so, the higher the nest the number, the more account ids there should be associated with it#
#so, allNests should be a originalLengthx3 array, where the first column = account ids to use when they search for a nesting level of 2, second column is nesting level of 3
output[2837,]
output[51,]
workDat[898,]
uniqueSearches[51]
uniqueSearch[51]
j = uniqueSearch[51]
j
which(workDat[,4]==j)
output[51,]
output[187,]
output[681,]
output[4097,]
output[1888,]
workDat[898:902,]
accountIds = c()#
for(j in uniqueSearch){#
	searchIndex = which(workDat[,4]==j)#
#
	if(length(searchIndex)>0){#
		value = workDat[searchIndex,5]#
	}else{#
		value = 0#
	}#
	if(length(value)>1) {#
		print("greater than 1..")#
		print(j)#
		print(value)#
	}	#
	accountIds = c(accountIds,value)#
}
accountIds
uniqueSearch[2719]
uniqueSearch[1888,]
uniqueSearch[1888]
workDat[898,]
setwd("/Users/raulfoo/Desktop")#
#
#dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
#dat = dat[is.na(dat[,3])==F,]#
#
#newID = c(1:dim(dat)[1])#
#dat[,3] = newID#
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#remove records where 2012 or 2013 = 0#
dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#
removes = which(dat[,64]==0 | dat[,65]==0) #
dat = dat[-removes,]#
dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
dat = dat[is.na(dat[,3])==F,]#
#
newID = c(1:dim(dat)[1])#
dat[,3] = newID#
temp = cbind(dat[,5],dat[,1],dat[,2],dat[,4],dat[,3],dat[,6])#
temp = toupper(temp)#
temp = cbind(temp,dat[,7:ncol(dat)]*1000)#
#
temp = gsub("\\(","--",temp)#
temp = gsub("\\)","--",temp)#
dat = temp
temp[898,]
dim(temp)
setwd("/Users/raulfoo/Desktop")#
#
#dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
#dat = dat[is.na(dat[,3])==F,]#
#
#newID = c(1:dim(dat)[1])#
#dat[,3] = newID#
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#remove records where 2012 or 2013 = 0#
dat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#
removes = which(dat[,64]==0 | dat[,65]==0) #
dat = dat[-removes,]#
dat= dat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
dat = dat[is.na(dat[,3])==F,]#
#
newID = c(1:dim(dat)[1])#
dat[,3] = newID#
temp = cbind(dat[,5],dat[,1],dat[,2],dat[,4],dat[,3],dat[,6])#
temp = toupper(temp)#
temp = cbind(temp,dat[,7:ncol(dat)]*1000)#
for(i in c(1:4)){#
	temp[,i] = gsub("\\(","--",temp[,i])#
	temp[,i] = gsub("\\)","--",temp[,i])#
}#
dat = temp#
#
#remove duplicates#
for(j in 1:nrow(dat)){#
	search = dat[j,]#
	indices = which(dat[,1]==search[,1]&dat[,2]==search[,2]&dat[,3]==search[,3]&dat[,4]==search[,4])#
	if(length(indices)>1){#
		removeRows = indices[2:length(indices)]#
		sums = as.numeric(apply(dat[indices,7:ncol(dat)],2,sum))#
		dat[j,7:ncol(dat)] = sums#
		#newRow = c(dat[j,1:6],sums)#
		#dat[j,] = newRow#
		dat = dat[-removeRows,]		#
	}#
	if(j%%250 == 0) print(j)#
}#
#
names(dat)[1:6] = c("SubFunction","Agency","Bureau","Account","Accunt Number","Spending Type")#
#
write.table(dat,"BudgetUS_Cleaned.txt",sep=",",row.names=F,col.names=F)#
#dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
newDat = read.csv("ComprehensiveBudget.csv",stringsAsFactors=F)#
#removes = which(newDat[,64]==0 | neDat[,65]==0) #
#newDat = newDat[-removes,]#
newDat= newDat[,-c(1,3,7,8,11,12)]#
#
#dat = dat[-(which(dat[,3]==0)),]#
newDat = newDat[is.na(newDat[,3])==F,]#
#
newID = c(1:dim(newDat)[1])#
newDat[,3] = newID#
temp = cbind(newDat[,5],newDat[,1],newDat[,2],newDat[,4],newDat[,3],newDat[,6])#
temp = toupper(temp)#
for(i in c(1:4)){#
	temp[,i] = gsub("\\(","--",temp[,i])#
	temp[,i] = gsub("\\)","--",temp[,i])#
}#
#
temp = cbind(temp,newDat[,7:ncol(newDat)]*1000)#
#
newDat = temp#
#
#remove duplicates#
for(j in 1:nrow(newDat)){#
	search = newDat[j,]#
	indices = which(newDat[,1]==search[,1]&newDat[,2]==search[,2]&newDat[,3]==search[,3]&newDat[,4]==search[,4])#
	if(length(indices)>1){#
		removeRows = indices[2:length(indices)]#
		sums = as.numeric(apply(newDat[indices,7:ncol(newDat)],2,sum))#
		newDat[j,7:ncol(newDat)] = sums#
		#newRow = c(dat[j,1:6],sums)#
		#dat[j,] = newRow#
		newDat = newDat[-removeRows,]		#
	}#
	if(j%%250 == 0) print(j)#
}#
#
names(newDat)[1:6] = c("SubFunction","Agency","Bureau","Account","Accunt Number","Spending Type")#
yearUse = c(1980:2015)#
#
averages = apply(dat[,c(7:ncol(dat))],1,mean)#
removePositives = which(averages < 0)#
#dat = dat[-removePositives,]#
#
#temp = cbind(dat[,3],dat[,-3])#
#dat = temp#
output = c()#
for(year in yearUse){#
	colIndex = which(names(dat)==paste("X",year,sep=""))#
	#total = sum(as.numeric(dat[,colIndex]))#
	total = sum(as.numeric(newDat[,colIndex]))#
	restrictedTotal = sum(as.numeric(dat[,colIndex]))#
	medicare = which(dat[,1]=="MEDICARE")#
	ss = which(dat[,1]=="SOCIAL SECURITY")#
	plain = c(1:nrow(dat))[-c(ss,medicare)]#
	restrictedTotal[medicare] = sum(as.numeric(dat[medicare,colIndex]))#
	restrictedTotal[ss] = sum(as.numeric(dat[ss,colIndex]))#
	restrictedTotal[plain] = sum(as.numeric(dat[plain,colIndex]))#
	print(paste(year,"  :  ",total))#
	temp = cbind(dat[,c(1:6)],year,dat[,colIndex]/total,dat[,colIndex]/restrictedTotal,dat[,colIndex],"f")#
	names(temp) = NA#
	output = rbind(output,temp)#
	names(output) = NA#
}#
output[,ncol(output)] = as.character(output[,ncol(output)])#
for(i in 1:nrow(output)){#
	if(output[i,1]=="SOCIAL SECURITY"){ #
		output[i,ncol(output)] = "SS"	#
	}else if(output[i,1]=="MEDICARE"){#
		output[i,ncol(output)] = "Medicare"	#
	}#
}#
write.table(output,"BudgetUs_Comprehensive.txt",sep=",",col.names=F,row.names=F)#
#---just some extra stuff#
negatives = which(as.integer(dat[,58])<=0)#
checkNeg = dat[negatives,c(1,2,3,4,58)]#
categories = as.data.frame(table(checkNeg[,1]))#
moneyMadeList = c()#
for(i in categories[,1]){#
	index = which(checkNeg[,1]==i)#
	moneyMade = sum(checkNeg[index,5])*-1#
	moneyMadeList = c(moneyMadeList,moneyMade)#
}#
#
categories = cbind(categories,moneyMadeList)#
categories
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
#
dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
workDat=dat#
#workDat[,2] = paste(temp[,2],temp[,1],sep=",")#
#workDat[,3] = paste(temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,4] = paste(temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#
#---IMPORTANT---#
#here is where we can change specificty#
#with all levels, payment at program level has to be traced back to the subfunction, which can lead to some weird numbers sometimes, if only start this on workDat[,3], leaving out the subfunction nesting, then will have more generalized (and maybe better) numbers. (but will need to retain the first subfunction rows so the search will be connected) Also, if change the --> connector, need to change code at bottom of search_programs library#
workDat[,2] = paste(dat[,1],dat[,2],sep="-->")#
workDat[,3] = paste(dat[,1],dat[,2],dat[,3],sep="-->")#
workDat[,4] = paste(dat[,1],dat[,2],dat[,3],dat[,4],sep="-->")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
uniqueSearch = c()#
thresholds = c()#
for(i in c(1:4)){#
	uniqueSearch = c(uniqueSearch,unique(workDat[,i]))#
	thresholds = rbind(thresholds,c(i,length(uniqueSearch)))#
	#take the measurement before add the ids#
	if(i == 3) searchLength = length(uniqueSearch)#
} #
#
uniqueSearch = gsub("\\(","--",uniqueSearch)#
uniqueSearch = gsub("\\)","--",uniqueSearch)#
thresholds = cbind(thresholds,c("subfunction","agency","bureau","program"))#
branchAddresses = c()#
for(j in 1:searchLength){#
	search_r = which(as.numeric(thresholds[,2])>=j)[1]#
	searchRange = c(((as.numeric(thresholds[search_r,2]))+1),as.numeric(thresholds[search_r+1,2]))#
	branchMap = grep(paste(uniqueSearch[j],"-->",sep=""),uniqueSearch)#
	branchMapSelect = which(branchMap>=searchRange[1] & branchMap<=searchRange[2])#
	branchMap = branchMap[branchMapSelect]#
	branchMap = paste(branchMap,collapse=",")#
	branchAddresses = rbind(branchAddresses,branchMap)#
#
	if(j %% 250 == 0) print(j)#
}#
#
#uniqueIds Column#
uniqueIds = c(1:length(uniqueSearch))#
#
#Browse names (last entry in the unqiueSearch)#
browseNames = c()#
base_level = c()#
index = 0#
for(i in uniqueSearch){#
	splits = strsplit(i,"-->")[[1]]#
	splitLength = length(splits)#
	thisBaseLevel = thresholds[splitLength,3]#
	browseWord = splits[splitLength]#
	browseNames = c(browseNames,browseWord)#
	base_level = c(base_level,thisBaseLevel)#
	if(index %% 250 == 0) print(index)#
	index = index+1#
}#
#
#searchable (only the first 80 entries)#
trueSearch = rep("nested",times=thresholds[1,2])#
falseSearch = rep("f",times=(length(uniqueSearch)-length(trueSearch)))#
#
searchables = c(trueSearch,falseSearch)#
#text search (same as searchables for now)#
textSearch = rep("f",times=length(searchables))#
#setup BranchId column#
#add zero values to branchMap for the account levels#
zeroes = rep(0, times=(length(uniqueSearch)-searchLength))#
branchAddressesAddColumn = c(branchAddresses,zeroes)#
#
#add account Ids for the lowest level, 0 for the others#
accountIds = c()#
for(j in uniqueSearch){#
	searchIndex = which(workDat[,4]==j)#
#
	if(length(searchIndex)>0){#
		value = workDat[searchIndex,5]#
	}else{#
		value = 0#
	}#
	if(length(value)>1) {#
		print("greater than 1..")#
		print(j)#
		print(value)#
	}	#
	accountIds = c(accountIds,value)#
}#
#
#base_level = rep("NA",times=length(uniqueSearch))#
#columns are (7)#
#1 unique search ID#
#2 search name, including all super levels#
#3 search name used for browsing (lowest level)#
#4 boolean, is this used for the first selection option#
#5 boolean, can this be searched with text (all the lowest levels, and the aggregates)#
#6 branches, unique search ids that are connected one level below this entry#
#7 trunks (parents) the 1 unique search value that can be associated with every branch#
#8 govt account ID numbers that comprise this entry (only for the aggregates and lowest levels)#
#9 sort value(for sorting in the browse window, aggregates get 1 and 2, everythin else is 0)#
#10 base level agency#
#
trunkIds = rep(0,rep=length(uniqueSearch))#
sortValues = rep(0,times=length(uniqueSearch))#
output = cbind(uniqueIds,uniqueSearch,browseNames,searchables,textSearch,branchAddressesAddColumn,trunkIds,accountIds,sortValues,base_level)#
for(trunkIndex in c(1:nrow(output))){#
	branches = as.numeric(strsplit(output[trunkIndex,6],",")[[1]])#
	output[branches,7] = trunkIndex#
}#
#
for(addStems in c(1:nrow(output))){#
	if(as.numeric(output[addStems,7])==0){#
		output[addStems,7] = output[addStems,1]#
	}#
}#
outputRowIndex = 1#
#
originalLength = nrow(output)#
for(k in 1:originalLength){#
	search = output[k,6]#
	rows = as.numeric(strsplit(search,",")[[1]])#
	branchList = c(rows)#
	maxIndex = 10#
	indexCount = 1#
	if(rows!=0 & length(rows)>0){#
		while(T){#
			testBranch = c()#
			rowSearch = output[rows,6]#
			for(eachRow in rowSearch){#
				rowStep = as.numeric(strsplit(eachRow[[1]],",")[[1]])#
				branchList = c(branchList,rowStep)#
				testBranch = c(testBranch,rowStep)#
				}#
			if(max(testBranch)==0) break#
			if(indexCount >= maxIndex) break#
			 #failsafe#
			indexCount = indexCount+1#
			rows = testBranch#
		}#
		account_ids = rows[which(rows>0)]#
		account_ids = output[account_ids,8]#
		temp = which(account_ids=="0")#
		if(length(temp)>0){#
			account_ids = account_ids[-temp]#
		}#
	}else{#
		account_ids = 0#
		}#
	#create 'All' entry#
	if(outputRowIndex <= searchLength){#
		trunkIndex = as.numeric(output[outputRowIndex,7])#
		#trunkIndex = outputRowIndex#
		unique_id = nrow(output)+1#
		textSearch = "t"#
		account_ids = unique(account_ids)#
		#if(outputRowIndex <= thresholds[,2]) textSearch = "t"#
		browseName = paste(output[outputRowIndex,3]," (All -- Total)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- Total)",sep="")#
#
		baseLevelCategory = output[outputRowIndex,10]#
		branch_ids = unique_id#
        #for the subfunction level only aggregates, need to make the trunkIndex = 0#
        if(output[outputRowIndex,10]=="subfunction") trunkIndex = 0  #
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,	branch_ids,trunkIndex,paste("All",paste(account_ids,collapse=","),sep=","),1,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#trunkIndex = as.numeric(output[outputRowIndex,7])#
		trunkIndex = outputRowIndex#
#
		unique_id = nrow(output)+1#
		browseName = paste(output[outputRowIndex,3]," (All -- List)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- List)",sep="")	#
		branch_ids = output[outputRowIndex,6]#
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,	branch_ids,trunkIndex,paste(account_ids,collapse=","),2,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#add these two to the branch Ids for the origianl search#
		output[outputRowIndex,6] = paste((nrow(output)-1),nrow(output),output[outputRowIndex,6],sep=",")#
		#if need to, add the account ids to this row as well, but shouldn't need too, as only will be accesses#
		output[outputRowIndex,8] = paste(account_ids,collapse=",")#
		#output[outputRowIndex,10] = baseLevelCategory#
	}#
	outputRowIndex = outputRowIndex +1#
	if((outputRowIndex %% 100) == 0) print(outputRowIndex)#
}	#
#
write.table(output,"uniqueSearches.txt",sep=",",col.names=F,row.names=F)#
allNests = c()#
workOutput = output[(originalLength+1):nrow(output),]#
workOutput[,2] = gsub("\\(","--",workOutput[,2])#
workOutput[,2] = gsub("\\)","--",workOutput[,2])#
for(nest in c(2:4)){#
	nestingValues = c()#
	#for(i in c(1:originalLength)){#
		for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "subfunction"){#
			rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
allNestsTemp = array(dim=c(originalLength,3),0) #
allNests = rbind(allNestsTemp,allNests)#
#output = cbind(output[,-8],output[,8])#
#
output = cbind(output,allNests)#
#
allNests = c()#
workOutput = output[1:originalLength,]#
#
for(nest in c(2:4)){#
	nestingValues = c()#
	#for(i in c(1:originalLength)){#
		for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "subfunction"){#
				rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
#allNestsTemp = array(dim=c((nrow(output)-nrow(allNests)),3),0)  #this is to cover all the aggregates#
#move account Ids to end#
#allNests = rbind(allNests,allNestsTemp)#
#output = cbind(output[,-8],output[,8])#
#output = cbind(output,allNests)#
#output = cbind(output[,-8],output[,8])#
#output = cbind(output,allNests)#
#
output[c(1:nrow(allNests)),c((ncol(output)-2):ncol(output))] = allNests#
#
output = cbind(output[,-c(8,(ncol(output)-2),(ncol(output)-1),ncol(output))],output[,8],output[,c((ncol(output)-2):ncol(output))])#
write.table(output,"uniqueSearchesNested.txt",sep=",",col.names=F,row.names=F)#
#
#nesting levels, 1 = default, fully nested, 2 = nested to two programs above, 3 = nested to program immediately above, 4 = no nesting, so, the higher the nest the number, the more account ids there should be associated with it#
#so, allNests should be a originalLengthx3 array, where the first column = account ids to use when they search for a nesting level of 2, second column is nesting level of 3
output[2837,]
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
#
topLevels = grep("All -- Total|All -- List",firstPart[,2])#
#
topLevelsFirst = topLevels[which(firstPart[topLevels,9]=="subfunction")]#
#
topLevels = grep("All -- Total|All -- List",secondPart[,2])#
#
topLevelsSecond = topLevels[which(secondPart[topLevels,9]=="agency")]+nrow(firstPart)#
topLevels = c(topLevelsFirst,topLevelsSecond)#
#
#pick subfunction and unnested subfunctions#
#topLevels = which(output[,4]!="f") #
dat = read.table("BudgetUs_Comprehensive.txt",sep=",",stringsAsFactors=F)#
dat = dat[which(dat[,7]==2012),]#
budgetSum = c()#
#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(workDat[,2])) <= abs(as.numeric(workDat[i,2])*1.5) & abs(as.numeric(workDat[,2])) >= abs(as.numeric(workDat[i,2])*.5) & workDat[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(workDat[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
#temp=c(1,20,3,67,73,64,18)#
#x = output[temp,]#
#
#y = paste(x[,10],collapse=",")#
#z = strsplit(y,",")[[1]]#
#search = paste("^",z,"$",sep="",collapse="|")#
#
#a = grep(search,dat[,5])#
#
#make a comparison_neighbors column#
neighborsList = c()#
badNeighbors =c()#
for(i in 1:nrow(output)){#
	if(output[i,7] != 0){#
	parent = which(output[,1] == output[i,7])#
	neighbors = output[parent,6]#
	neighbors = strsplit(neighbors,",")[[1]]#
	neighbors = neighbors[3:length(neighbors)]#
	if(length(neighbors)<2) badNeighbors = c(badNeighbors,i)#
	neighbors = neighbors[sample(1:length(neighbors),min(6,length(neighbors)))]#
	neighbors = unique(c(output[i,1],neighbors))#
	neighbors = paste(neighbors,collapse=",")#
	}else{#
		neighbors = 0#
	}#
	neighborsList = c(neighborsList,neighbors)#
}#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
#output = cbind(output,neighborsList)#
#
#lets do something to add neighbors for ones that are nested without many natural neighbors#
#
budgetSum = c()#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
budgetSum = c()#
aggregates = grep("All -- List|All -- Total",output[,3])#
topLevels = output[-aggregates,1]#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
Eligibles = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*1.5) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
#
dat = read.table("BudgetUS_Cleaned.txt",sep=",",stringsAsFactors=F)#
dat = dat[,-1]#
workDat=dat#
#workDat[,2] = paste(temp[,2],temp[,1],sep=",")#
#workDat[,3] = paste(temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,4] = paste(temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
#
#---IMPORTANT---#
#here is where we can change specificty#
#with all levels, payment at program level has to be traced back to the subfunction, which can lead to some weird numbers sometimes, if only start this on workDat[,3], leaving out the subfunction nesting, then will have more generalized (and maybe better) numbers. (but will need to retain the first subfunction rows so the search will be connected) Also, if change the --> connector, need to change code at bottom of search_programs library#
workDat[,2] = paste(dat[,1],dat[,2],sep="-->")#
workDat[,3] = paste(dat[,1],dat[,2],dat[,3],sep="-->")#
#workDat[,4] = paste(dat[,1],dat[,2],dat[,3],dat[,4],sep="-->")#
#workDat[,5] = paste(temp[,5],temp[,4],temp[,3],temp[,2],temp[,1],sep=",")#
uniqueSearch = c()#
thresholds = c()#
for(i in c(1:3)){#
	uniqueSearch = c(uniqueSearch,unique(workDat[,i]))#
	thresholds = rbind(thresholds,c(i,length(uniqueSearch)))#
	#take the measurement before add the ids#
	if(i == 2) searchLength = length(uniqueSearch)#
} #
#
uniqueSearch = gsub("\\(","--",uniqueSearch)#
uniqueSearch = gsub("\\)","--",uniqueSearch)#
thresholds = cbind(thresholds,c("agency","bureau","program"))#
branchAddresses = c()#
for(j in 1:searchLength){#
	search_r = which(as.numeric(thresholds[,2])>=j)[1]#
	searchRange = c(((as.numeric(thresholds[search_r,2]))+1),as.numeric(thresholds[search_r+1,2]))#
	branchMap = grep(paste(uniqueSearch[j],"-->",sep=""),uniqueSearch)#
	branchMapSelect = which(branchMap>=searchRange[1] & branchMap<=searchRange[2])#
	branchMap = branchMap[branchMapSelect]#
	branchMap = branchMap + nrow(firstPart)#
	branchMap = paste(branchMap,collapse=",")#
	branchAddresses = rbind(branchAddresses,branchMap)#
#
	if(j %% 250 == 0) print(j)#
}#
#
#uniqueIds Column#
uniqueIds = c((nrow(firstPart)+1):(nrow(firstPart)+length(uniqueSearch)))#
#
#Browse names (last entry in the unqiueSearch)#
browseNames = c()#
base_level = c()#
index = 0#
for(i in uniqueSearch){#
	splits = strsplit(i,"-->")[[1]]#
	splitLength = length(splits)#
	thisBaseLevel = thresholds[splitLength,3]#
	browseWord = splits[splitLength]#
	browseNames = c(browseNames,browseWord)#
	base_level = c(base_level,thisBaseLevel)#
	if(index %% 250 == 0) print(index)#
	index = index+1#
}#
#
#searchable (only the first 80 entries)#
trueSearch = rep("unested",times=thresholds[1,2])#
falseSearch = rep("f",times=(length(uniqueSearch)-length(trueSearch)))#
#
searchables = c(trueSearch,falseSearch)#
#text search (same as searchables for now)#
textSearch = rep("f",times=length(searchables))#
#setup BranchId column#
#add zero values to branchMap for the account levels#
zeroes = rep(0, times=(length(uniqueSearch)-searchLength))#
branchAddressesAddColumn = c(branchAddresses,zeroes)#
#
#add account Ids for the lowest level, 0 for the others#
accountIds = c()#
for(j in uniqueSearch){#
	searchIndex = which(workDat[,3]==j)#
	if(length(searchIndex)>0){#
		value = workDat[searchIndex,4]#
	}else{#
		value = 0#
	}#
	if(length(value)>1) {#
		print("greater than 1..")#
		print(j)#
		print(value)#
		value = paste(value,collapse=",") #I think this will be ok ruby side..#
	}	#
	accountIds = c(accountIds,value)#
}#
#
#base_level = rep("NA",times=length(uniqueSearch))#
#columns are (7)#
#1 unique search ID#
#2 search name, including all super levels#
#3 search name used for browsing (lowest level)#
#4 boolean, is this used for the first selection option#
#5 boolean, can this be searched with text (all the lowest levels, and the aggregates)#
#6 branches, unique search ids that are connected one level below this entry#
#7 trunks (parents) the 1 unique search value that can be associated with every branch#
#8 govt account ID numbers that comprise this entry (only for the aggregates and lowest levels)#
#9 sort value(for sorting in the browse window, aggregates get 1 and 2, everythin else is 0)#
#10 base level agency#
#
trunkIds = rep(0,times=length(uniqueSearch))#
sortValues = rep(0,times=length(uniqueSearch))#
output = cbind(uniqueIds,uniqueSearch,browseNames,searchables,textSearch,branchAddressesAddColumn,trunkIds,accountIds,sortValues,base_level)#
for(trunkIndex in c(1:nrow(output))){#
	branches = as.numeric(strsplit(output[trunkIndex,6],",")[[1]])#
	if(sort(branches)[1] != 0){#
	output[(branches-nrow(firstPart)),7] = trunkIndex+nrow(firstPart)#
	}#
}#
#
for(addStems in c(1:nrow(output))){#
	if(as.numeric(output[addStems,7])==0){#
		output[addStems,7] = output[addStems,1]#
	}#
}#
outputRowIndex = 1#
#
originalLength = nrow(output)#
for(k in 1:originalLength ){#
	search = output[k,6]#
	rows = as.numeric(strsplit(search,",")[[1]])#
	branchList = c(rows)#
	maxIndex = 10#
	indexCount = 1#
	if(rows!=0 && length(rows)>0){#
		while(T){#
			testBranch = c()#
			rowSearch = output[(rows-nrow(firstPart)),6]#
			for(eachRow in rowSearch){#
				rowStep = as.numeric(strsplit(eachRow[[1]],",")[[1]])#
				branchList = c(branchList,rowStep)#
				testBranch = c(testBranch,rowStep)#
				}#
			if(max(testBranch)==0) break#
			if(indexCount >= maxIndex) break#
			 #failsafe#
			indexCount = indexCount+1#
			rows = as.numeric(testBranch)#-nrow(firstPart)#
		}#
		account_ids = rows[which(rows>0)]#
		account_ids = output[(account_ids-nrow(firstPart)),8]#
		temp = which(account_ids=="0")#
		if(length(temp)>0){#
			account_ids = account_ids[-temp]#
		}#
#
	}else{#
		account_ids = 0#
		}#
	#create 'All' entry#
	if(outputRowIndex <= searchLength){#
		trunkIndex = as.numeric(output[outputRowIndex,7])#
		#trunkIndex = outputRowIndex+nrow(firstPart)#
		unique_id =  nrow(output)+nrow(firstPart)+1#
		textSearch = "t"#
#
		account_ids = unique(account_ids)#
		browseName = paste(output[outputRowIndex,3]," (All -- Total)",sep="")#
		allLevelName = browseName#
		allLevelName = paste(output[outputRowIndex,2]," (All -- Total)",sep="")#
#
		baseLevelCategory = output[outputRowIndex,10]#
		branch_ids = unique_id#
        #for the subfunction level only aggregates, need to make the trunkIndex = 0#
        if(output[outputRowIndex,10]=="agency") trunkIndex = 0  #
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,branch_ids,trunkIndex,paste("All",paste(account_ids,collapse=","),sep=","),1,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#trunkIndex = as.numeric(output[outputRowIndex,7])#
		trunkIndex = outputRowIndex+nrow(firstPart)#
		unique_id = unique_id+1#
		browseName = paste(output[outputRowIndex,3]," (All -- List)",sep="")#
		allLevelName = paste(output[outputRowIndex,2]," (All -- List)",sep="")		#
		branch_ids = output[outputRowIndex,6]#
		rowOutput = c(unique_id,allLevelName,browseName,"f",textSearch,branch_ids,trunkIndex,paste(account_ids,collapse=","),2,baseLevelCategory)#
		output = rbind(output,rowOutput)#
		#add these two to the branch Ids for the origianl search#
		output[outputRowIndex,6] = paste((nrow(output)+nrow(firstPart)-1),(nrow(output)+nrow(firstPart)),output[outputRowIndex,6],sep=",")#
		#if need to, add the account ids to this row as well, but shouldn't need too, as only will be accesses#
		output[outputRowIndex,8] = paste(account_ids,collapse=",")#
		#output[outputRowIndex,10] = baseLevelCategory#
	}#
	outputRowIndex = outputRowIndex +1#
	if((outputRowIndex %% 100) == 0) print(outputRowIndex)#
}	#
#
#write.table(output,"uniqueSearches.txt",sep=",",col.names=F,row.names=F)#
allNests = c()#
#
workOutput = output[(originalLength+1):nrow(output),]#
workOutput[,2] = gsub("\\(","--",workOutput[,2])#
workOutput[,2] = gsub("\\)","--",workOutput[,2])#
#
for(nest in c(2:4)){#
	nestingValues = c()#
	for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "agency"){#
				rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				k = gsub("All,","",k)#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
allNestsTemp = array(dim=c(originalLength,3),0) #
allNests = rbind(allNestsTemp,allNests)#
#
output = cbind(output,allNests)#
allNests = c()#
#
workOutput = output[1:originalLength,]#
for(nest in c(2:4)){#
	nestingValues = c()#
	for(i in c(1:nrow(workOutput))){#
		search = workOutput[i,2]#
		levels = strsplit(search,"-->")[[1]]#
		if(length(levels) < nest){#
			nestingValues = rbind(nestingValues,workOutput[i,8])#
			next#
		}else{#
			newSearch = levels[nest:length(levels)]#
			if(workOutput[i,10] != "agency"){#
				rebuild = paste("-->",paste(newSearch,collapse="-->"),"$",sep="")#
			}else{#
				rebuild = paste(paste(newSearch,collapse="-->"),"$",sep="")#
				}#
			matches = grep(rebuild,workOutput[,2])#
			matches = matches[which(workOutput[matches,10]==workOutput[i,10])]#
			allAccountIds = workOutput[matches,8]#
			cumulative = c()#
			for(k in allAccountIds){#
				temp = strsplit(k,",")[[1]]#
				templist = c()#
				for(z in temp){#
					templist = c(templist,as.numeric(z))#
					}#
				cumulative = c(cumulative,templist)#paste(cumulative,k,sep=",")#
			}#
			#then check for duplicates, remove and rebuild the string#
			#checkUniques = strsplit(cumulative,",")[[1]]#
			uniques = unique(cumulative)#
			rebuild = paste(uniques,collapse=",")#
			nestingValues = rbind(nestingValues,rebuild)#
		}#
		if((i %% 250) == 0) print(paste("Nest:",nest,", row: ",i,sep=""))#
	}#
	allNests =  cbind(allNests,nestingValues)#
}#
#
#allNestsTemp = array(dim=c((nrow(output)-nrow(allNests)),3),0)  #this is to cover all the aggregates#
#move account Ids to end#
#allNests = rbind(allNests,allNestsTemp)#
#output = cbind(output[,-8],output[,8])#
output[c(1:nrow(allNests)),c((ncol(output)-2):ncol(output))] = allNests#
output = cbind(output[,-c(8,(ncol(output)-2),(ncol(output)-1),ncol(output))],output[,8],output[,c((ncol(output)-2):ncol(output))])#
#make the branch trunk tree only use aggregates#
write.table(output,"uniqueSearches_UnNested.txt",sep=",",col.names=F,row.names=F)#
#
#nesting levels, 1 = default, fully nested, 2 = nested to two programs above, 3 = nested to program immediately above, 4 = no nesting, so, the higher the nest the number, the more account ids there should be associated with it#
#so, allNests should be a originalLengthx3 array, where the first column = account ids to use when they search for a nesting level of 2, second column is nesting level of 3
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
#
topLevels = grep("All -- Total|All -- List",firstPart[,2])#
#
topLevelsFirst = topLevels[which(firstPart[topLevels,9]=="subfunction")]#
#
topLevels = grep("All -- Total|All -- List",secondPart[,2])#
#
topLevelsSecond = topLevels[which(secondPart[topLevels,9]=="agency")]+nrow(firstPart)#
topLevels = c(topLevelsFirst,topLevelsSecond)#
#
#pick subfunction and unnested subfunctions#
#topLevels = which(output[,4]!="f") #
dat = read.table("BudgetUs_Comprehensive.txt",sep=",",stringsAsFactors=F)#
dat = dat[which(dat[,7]==2012),]#
budgetSum = c()#
#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(workDat[,2])) <= abs(as.numeric(workDat[i,2])*1.5) & abs(as.numeric(workDat[,2])) >= abs(as.numeric(workDat[i,2])*.5) & workDat[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(workDat[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
#temp=c(1,20,3,67,73,64,18)#
#x = output[temp,]#
#
#y = paste(x[,10],collapse=",")#
#z = strsplit(y,",")[[1]]#
#search = paste("^",z,"$",sep="",collapse="|")#
#
#a = grep(search,dat[,5])#
#
#make a comparison_neighbors column#
neighborsList = c()#
badNeighbors =c()#
for(i in 1:nrow(output)){#
	if(output[i,7] != 0){#
	parent = which(output[,1] == output[i,7])#
	neighbors = output[parent,6]#
	neighbors = strsplit(neighbors,",")[[1]]#
	neighbors = neighbors[3:length(neighbors)]#
	if(length(neighbors)<2) badNeighbors = c(badNeighbors,i)#
	neighbors = neighbors[sample(1:length(neighbors),min(6,length(neighbors)))]#
	neighbors = unique(c(output[i,1],neighbors))#
	neighbors = paste(neighbors,collapse=",")#
	}else{#
		neighbors = 0#
	}#
	neighborsList = c(neighborsList,neighbors)#
}#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
#output = cbind(output,neighborsList)#
#
#lets do something to add neighbors for ones that are nested without many natural neighbors#
#
budgetSum = c()#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
budgetSum = c()#
aggregates = grep("All -- List|All -- Total",output[,3])#
topLevels = output[-aggregates,1]#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
Eligibles = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*1.5) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
#
topLevels = grep("All -- Total|All -- List",firstPart[,2])#
#
topLevelsFirst = topLevels[which(firstPart[topLevels,9]=="subfunction")]#
#
topLevels = grep("All -- Total|All -- List",secondPart[,2])#
#
topLevelsSecond = topLevels[which(secondPart[topLevels,9]=="agency")]+nrow(firstPart)#
topLevels = c(topLevelsFirst,topLevelsSecond)#
#
#pick subfunction and unnested subfunctions#
#topLevels = which(output[,4]!="f") #
dat = read.table("BudgetUs_Comprehensive.txt",sep=",",stringsAsFactors=F)#
dat = dat[which(dat[,7]==2012),]#
budgetSum = c()#
#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(workDat[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(workDat[,2])) >= abs(as.numeric(workDat[i,2])*.5) & workDat[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(workDat[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
#temp=c(1,20,3,67,73,64,18)#
#x = output[temp,]#
#
#y = paste(x[,10],collapse=",")#
#z = strsplit(y,",")[[1]]#
#search = paste("^",z,"$",sep="",collapse="|")#
#
#a = grep(search,dat[,5])#
#
#make a comparison_neighbors column#
neighborsList = c()#
badNeighbors =c()#
for(i in 1:nrow(output)){#
	if(output[i,7] != 0){#
	parent = which(output[,1] == output[i,7])#
	neighbors = output[parent,6]#
	neighbors = strsplit(neighbors,",")[[1]]#
	neighbors = neighbors[3:length(neighbors)]#
	if(length(neighbors)<2) badNeighbors = c(badNeighbors,i)#
	neighbors = neighbors[sample(1:length(neighbors),min(6,length(neighbors)))]#
	neighbors = unique(c(output[i,1],neighbors))#
	neighbors = paste(neighbors,collapse=",")#
	}else{#
		neighbors = 0#
	}#
	neighborsList = c(neighborsList,neighbors)#
}#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
#output = cbind(output,neighborsList)#
#
#lets do something to add neighbors for ones that are nested without many natural neighbors#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
budgetSum = c()#
aggregates = grep("All -- List|All -- Total",output[,3])#
topLevels = output[-aggregates,1]#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
Eligibles = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
output[2837,]
topLevels
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
neighborsList = c(1:nrow(output))#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
Eligibles = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)
output[2837,]
output[2753,]
output[51,]
output[2794,]
topLevels
output[1,2]
output[1,3]
output[3000,3]
output[3000,2]
grep("All --List--|All --Total--",output[,3])
grep("All (List)|All (Total)",output[,3])
grep("All -- List|All -- Total",output[,3])
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
neighborsList = c(1:nrow(output))#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All --List--|All --Total--",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
output[2837,]
Eligibles
topLevels
aggregateRemove
grep("All --List--|All --Total--",output[,3])
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
neighborsList = c(1:nrow(output))#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All --List--|All --Total--",output[,3])
aggregateRemove
grep("All --List--|All --Total--",output[,3])
output[1,]
output[1,3]
output[3000,3]
aggregateRemove = grep("All --List|All --Total",output[,3])
aggregateRemove
grep("All --List|All --Total",output[,3])
output[3000,3]
aggregateRemove = grep("All -- List|All -- Total",output[,3])
aggregateRemove
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])
dim(Eligibles)
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
output[2837,]
output[51,]
i = 2837
similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])
similar
similar = similar[-which(similar==i)]#
	choose = sample(c(1:length(similar)),min(6,length(similar)))
similar
similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}
similar
choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)
newNeighbors
neighbor
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
neighborsList = c(1:nrow(output))#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
#
output = cbind(output,neighborsList)#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
output[2837,]
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
workOut = output#
#
output = workOut[1:nrow(firstPart),]#
#
neighborsList = c(1:nrow(workOut))#
#
budgetSum = c()#
badNeighbors = 1:nrow(firstPart)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(firstPart)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
workOut = cbind(workOut,neighborsList)#
output = workOut
newNeighbors[1]
newNeighbors[5000]
newNeighbors[4000]
length(newNeighbors)
length(newNeighbors[4800])
length(newNeighbors[4801])
length(newNeighbors[4810])
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
workOut = output#
#
output = workOut[1:nrow(firstPart),]#
#
neighborsList = c(1:nrow(workOut))#
#
budgetSum = c()#
badNeighbors = 1:nrow(firstPart)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(firstPart)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])
length(neighborsList)
neighborsList[1]
neighborsList[4000]
neighborsList[5000]
neighborsList[6000]
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])
dim(Eligibles)
Eligibles[1,]
Eligibles[2,]
workDat[1,]
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors
topLevels[1]
i = 1
output[i,10]
search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])
index
budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget)
budgetSum
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels+nrow(firstPart),as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind(topLevels[-aggregateRemove],as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])
workDat[1,]
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}
neighborsList[1]
neighborsList[5000]
newNeighbors
Eligibles[1:50,]
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels+nrow(firstPart),as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- List|All -- Total",output[,3])#
Eligibles = cbind((topLevels[-aggregateRemove]+nrow(firstPart)),as.numeric(budgetSum)[-aggregateRemove],output[topLevels[-aggregateRemove],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}
neighborsList[1]
neighborsList[100]
neighborsList[1000]
neighborsList[000]
neighborsList[500]
neighborsList[5000]
neighborsList[6000]
workOut = cbind(workOut,neighborsList)
output = workOut#
#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
output[238,]
output[340,]
output[238,]
output[208,]
output[259,]
output[340,]
output[111,]
output[259,]
setwd("/Users/raulfoo/BudgetUs/BudgetUs_R_Scripts")#
firstPart = read.table("uniqueSearchesNested.txt",sep=",",stringsAsFactors=F)#
secondPart = read.table("uniqueSearches_UnNested.txt",sep=",",stringsAsFactors=F)#
#
output = rbind(firstPart,secondPart)#
workOut = output#
#
output = workOut[1:nrow(firstPart),]#
#
neighborsList = c(1:nrow(workOut))#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels,as.numeric(budgetSum),output[topLevels,9])#
#
aggregateRemove = grep("All -- Total",output[,3])#
programs = which(output[,10]=="program")#
both = c(aggregateRemove,programs)#
Eligibles = cbind(topLevels[both],as.numeric(budgetSum)[both],output[topLevels[both],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
output = workOut[(nrow(firstPart)+1):nrow(workOut),]#
#
budgetSum = c()#
badNeighbors = 1:nrow(output)#
topLevels = badNeighbors#
for(i in topLevels){#
	search = output[i,10]#
	search = strsplit(search,",")[[1]]#
	search = paste("^",search,"$",sep="",collapse="|")#
	index = grep(search,dat[,5])#
	budget = sum(dat[index,9])#
	budgetSum = c(budgetSum,budget) #
}#
#
workDat = cbind(topLevels+nrow(firstPart),as.numeric(budgetSum),output[topLevels,9])#
#
#change so it only keeps aggregates and lowest levels#
aggregateRemove = grep("All -- Total",output[,3])#
programs = which(output[,10]=="program")#
both = c(aggregateRemove,programs)#
Eligibles = cbind((topLevels[both]+nrow(firstPart)),as.numeric(budgetSum)[both],output[topLevels[both],9])#
newNeighbors = c()#
for(i in 1:nrow(workDat)){#
	similar = which(abs(as.numeric(Eligibles[,2])) <= abs(as.numeric(workDat[i,2])*2) & abs(as.numeric(Eligibles[,2])) >= abs(as.numeric(workDat[i,2])*.5) & Eligibles[,3] == workDat[i,3])#
	if(length(which(similar==i))>0){#
		similar = similar[-which(similar==i)]#
	}#
	choose = sample(c(1:length(similar)),min(6,length(similar)))#
	neighbor = paste(as.numeric(workDat[i,1]),paste(Eligibles[similar[choose],1],collapse=","),sep=",")#
	newNeighbors = c(newNeighbors,neighbor)#
}#
workDat = cbind(workDat,newNeighbors)#
for(i in 1:nrow(workDat)){#
	neighborsList[as.numeric(workDat[i,1])] = workDat[i,4]#
}#
workOut = cbind(workOut,neighborsList)#
output = workOut#
#
write.table(output,"uniqueSearchesAll.txt",sep=",",row.names=F,col.names=F)
output[300,]
output[2957,]
output[3253,]
output[3351,]
output[3539,]
output[3015,]
output[3015,]
